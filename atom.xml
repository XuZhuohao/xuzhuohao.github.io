<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yui_HTT</title>
  
  
  <link href="https://xuzhuohao.github.io/atom.xml" rel="self"/>
  
  <link href="https://xuzhuohao.github.io/"/>
  <updated>2021-03-29T02:52:58.963Z</updated>
  <id>https://xuzhuohao.github.io/</id>
  
  <author>
    <name>Yui_HTT</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>github workflows</title>
    <link href="https://xuzhuohao.github.io/2021/03/27/github-workflows/"/>
    <id>https://xuzhuohao.github.io/2021/03/27/github-workflows/</id>
    <published>2021-03-27T15:39:27.000Z</published>
    <updated>2021-03-29T02:52:58.963Z</updated>
    
    <content type="html"><![CDATA[<h1>workflows</h1><h2 id="0-参考文档">0.参考文档</h2><ol><li><a href="https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions">工作流程语法</a></li><li><a href="https://docs.github.com/cn/github/authenticating-to-github/creating-a-personal-access-token">创建个人访问令牌</a></li><li><a href="https://github.com/marketplace?type=actions">官方 action 仓库</a></li><li><a href="https://github.com/sdras/awesome-actions">awesome-actions 仓库</a></li></ol><h2 id="1-base">1.base</h2><h3 id="1-1-创建-workflows-流程">1.1 创建 workflows 流程</h3><p><strong>创建 workflows 文件有两种方式：</strong></p><p><strong>第一种是在仓库./.github/workflows/ 目录下创建 yaml 文件，</strong></p><p><strong>第二种方式是在github action 中创建，并用在线编辑器编写，一下使用这种方式演示</strong></p><span id="more"></span>>><p><img src="https://raw.githubusercontent.com/XuZhuohao/picture/master/github/workflows/create_actions.png" alt="create_action"></p><p>第一步先 选中 actions 选项卡，然后根据自己需求创建 yml 脚本</p><ul><li>选中 <code>set up a workflow yourself</code>  创建普通 yml 模板文件</li><li>或者选中 github 感觉项目代码推荐的模板</li></ul><hr><p><img src="https://raw.githubusercontent.com/XuZhuohao/picture/master/github/workflows/create_actions_01.png" alt="create_actions_01"></p><p>第二步使用在线编辑器编辑，编辑器页面主要使用有：</p><ul><li>上方填写文件名（生成后为 ./github/workflows/name.yml 文件）</li><li>主要区域是编辑器</li><li>右方式官方 action 市场，和简要文档</li></ul><p>写完后通过右上角 <code>start commit</code> 按钮提交</p><hr><p><img src="https://raw.githubusercontent.com/XuZhuohao/picture/master/github/workflows/action_job.png" alt="action_job"></p><p>创建完文件后，<code>Action</code> 选项卡会变成如上图界面，左边区域为所有 workflows，点击对应的 workflows(这里点中 hero-deploy 任务)，右边展示对应 workflows 的执行记录和过滤器，点击对应记录可以看到各个执行记录</p><hr><p><img src="https://raw.githubusercontent.com/XuZhuohao/picture/master/github/workflows/action_job_log_1.png" alt="action_job"></p><p>显示 hero-deploy 里的所有任务完成情况（这里只有一个任务）</p><hr><p><img src="https://raw.githubusercontent.com/XuZhuohao/picture/master/github/workflows/action_job_log_2.png" alt="action_job"></p><p>查看详细每个任务里面的每一个<code>step</code>的日志</p><hr><h3 id="1-2-示例：auto-build-deploy-hero-blog">1.2 示例：auto build&amp;deploy hero blog</h3><h4 id="1-2-1-说明">1.2.1 说明</h4><ol><li><a href="https://github.com/XuZhuohao/hexo-project-src">对应 github 仓库点击查看</a></li><li>参考章节 [1.1](### 1.1 创建 workflows 流程)</li><li><code>workflows</code> 运行于仓库 <code>hexo-project-src</code> ，运行产出物推送到仓库 <code>xuzhuohao.github.io</code></li><li>流程场景说明：<ul><li>在使用 hero 根据 markdown 生成 blog 代码，并在 github 发布，作用域名访问时，常需要如下操作：<ol><li>安装 npm，git，hexo-cli，clone code，npm install ( <em>第一次在电脑上使用</em>)</li><li>把新增的 markdown 放到 <code>hexo-project-src</code> 项目下 (<em>每次都要</em>)</li><li>使用 hexo 生成静态文件(hexo clean &amp;&amp; hexo g) (<em>每次都要</em>)</li><li>把静态文件推送到仓库 <code>xuzhuohao.github.io</code></li><li>把更新的 markdown 提交到仓库 <code>hexo-project-src</code></li></ol></li><li>该过程过于繁琐和复制</li><li>使用 <code>workflows</code> 后操作如下：<ol><li>提交新增 markdown 到仓库 <code>hexo-project-src</code> (通过git，或者直接 github web 提交)</li><li>自动化构建和发布(不需要操作)</li></ol></li><li>使用 <code>workflows</code>，让自己偷个懒吧</li></ul></li></ol><hr><h4 id="1-2-2-流程演示">1.2.2 流程演示</h4><h5 id="step1-生成并配置-secrets-ACCESS-TOKEN-供-step2-使用"><strong>step1:</strong> 生成并配置 <code>secrets.ACCESS_TOKEN</code> 供 step2 使用</h5><ol><li><p>在账号设置中获取 access_token (settings -&gt; Developer settings -&gt; Personal access tokens)</p><ul><li>settings</li></ul><p><img src="https://raw.githubusercontent.com/XuZhuohao/picture/master/github/workflows/example_setting_01.png" alt="example_setting_01"></p><ul><li>Developer settings</li></ul><p><img src="https://raw.githubusercontent.com/XuZhuohao/picture/master/github/workflows/example_setting_02.png" alt="example_setting_02"></p><ul><li>Personal access tokens (cenerate)</li></ul><p><img src="https://raw.githubusercontent.com/XuZhuohao/picture/master/github/workflows/example_setting_03.png" alt="example_setting_03"></p><ul><li>填写token名称和根据需求勾选对应权限，拉到最下面点击 cenerate 创建 token</li></ul><p><img src="https://raw.githubusercontent.com/XuZhuohao/picture/master/github/workflows/example_setting_04.png" alt="example_setting_4"></p><ul><li>生成token（需要负责处理自己保存，离开页面后再次进入，只显示之前取得名称了）</li></ul><p><img src="https://raw.githubusercontent.com/XuZhuohao/picture/master/github/workflows/example_setting_05.png" alt="example_setting_05"></p></li><li><p>打开仓库 <code>hexo-project-src</code>，配置 <code>ACCESS_TOKEN</code></p><ul><li>点击 Settings 标签页，点击 Secrets 选项，点击 New repository secret 按钮</li></ul><p><img src="https://raw.githubusercontent.com/XuZhuohao/picture/master/github/workflows/example_setting_06.png" alt="example_setting_06"></p><ul><li>参数命名并填写对应的值（在<code>workflows</code>中的使用方法为 <code>$&#123;&#123;secrets,yourName&#125;&#125;</code> ）</li></ul><p><img src="https://raw.githubusercontent.com/XuZhuohao/picture/master/github/workflows/example_setting_07.png" alt="example_setting_07"></p></li></ol><hr><h5 id="step2-根据-1-1-在仓库-hexo-project-src-创建并提交-workflows文件如下："><strong>step2:</strong> 根据 <code>1.1</code> 在仓库 <code>hexo-project-src</code> 创建并提交 <code>workflows文件</code>如下：</h5><p>文件 .github/workflows/hero-deploy.yml : <a href="https://github.com/XuZhuohao/hexo-project-src/blob/master/.github/workflows/hero-deploy.yml">github address</a></p><pre><code class="language-yaml"># workflows namename: hero-deploy# 触发条件：master pushon:  push:    branches: [ master ]    # 任务    jobs:  # 任务1：deploy(job_id)  deploy:    # deploy 任务的名称(说明)    name: deploy hero project    # 运行环境(GitHub 托管的运行器)    runs-on: ubuntu-latest    # 步骤    steps:      # 步骤1：每一步可以使用不同的action或者run不同的指令      - name: checkout code        uses: actions/checkout@master            - name: install node        uses: actions/setup-node@v1        with:          node-version: 12.x            - name: cache node modules        uses: actions/cache@v1        with:          path: ~/.npm          key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles('**/package-lock.json') &#125;&#125;            - name: install hero        run: |          npm install hexo-cli gulp -g          npm install                - name: generate file        run: |          hexo clean          hexo generate       #       - name: Execute gulp task#         run: gulp                 - name: deploy hexo        env:           # Github 仓库          GITHUB_REPO: github.com/XuZhuohao/xuzhuohao.github.io        # 推送        run: |          cd ./public &amp;&amp; git init &amp;&amp; git add          git config user.name &quot;yui_htt&quot;          git config user.email &quot;786725551@qq.com&quot;          git add *          git commit -m &quot;GitHub Actions Auto Builder at $(date +'%Y-%m-%d %H:%M:%S')&quot;          git push --force --quiet &quot;https://$&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;@$GITHUB_REPO&quot; master:master</code></pre><p>该脚本大意如下：</p><ul><li>创建一个 <code>workflows</code>，名字为 hero-deploy， 触发条件为 <code>master</code> 分支接受到 <code>push</code> 请求</li><li>该 <code>workflows</code> 包含一个 <code>job</code>， <code>job</code> 步骤如下：<ol><li>代码 checkout</li><li>使用 node.js 镜像</li><li>使用缓存</li><li>npm instal 项目以及项目操作所需要的 hexo-cli 和 gulp 程序</li><li>执行 hexo 指令，生成部署文件 <code>public</code>  文件夹</li><li>将生成的 <code>public</code> 文件夹推送到仓库 <code>xuzhuohao.github.io</code>（<strong>注意这里是另一个仓库了</strong>）</li><li>注意最后推送记录的 <code>secrets.ACCESS_TOKEN</code> 在 step1 已经进行创建</li></ol></li></ul><h3 id="1-3-基础语法">1.3 基础语法</h3><pre><code class="language-yaml">name: the-workflows-nameson:   push:     targs:      - &quot;*&quot;      jobs:   job1:     name: job1-name     steps:       - name: first step         run: echo hello word                - name : second step         uses: actions/checkout@v2         with:           ref: $&#123;&#123;github.ref&#125;&#125;</code></pre><p><strong>未完待续</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1&gt;workflows&lt;/h1&gt;
&lt;h2 id=&quot;0-参考文档&quot;&gt;0.参考文档&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.github.com/cn/actions/reference/workflow-syntax-for-github-actions&quot;&gt;工作流程语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.github.com/cn/github/authenticating-to-github/creating-a-personal-access-token&quot;&gt;创建个人访问令牌&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/marketplace?type=actions&quot;&gt;官方 action 仓库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/sdras/awesome-actions&quot;&gt;awesome-actions 仓库&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-base&quot;&gt;1.base&lt;/h2&gt;
&lt;h3 id=&quot;1-1-创建-workflows-流程&quot;&gt;1.1 创建 workflows 流程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;创建 workflows 文件有两种方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种是在仓库./.github/workflows/ 目录下创建 yaml 文件，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二种方式是在github action 中创建，并用在线编辑器编写，一下使用这种方式演示&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="other" scheme="https://xuzhuohao.github.io/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>这样读书就够了</title>
    <link href="https://xuzhuohao.github.io/2021/03/02/%E8%BF%99%E6%A0%B7%E8%AF%BB%E4%B9%A6%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>https://xuzhuohao.github.io/2021/03/02/%E8%BF%99%E6%A0%B7%E8%AF%BB%E4%B9%A6%E5%B0%B1%E5%A4%9F%E4%BA%86/</id>
    <published>2021-03-02T10:44:29.000Z</published>
    <updated>2021-03-29T02:52:58.963Z</updated>
    
    <content type="html"><![CDATA[<h1>这样读书就够了</h1><h2 id="0-引言">0. 引言</h2><h3 id="0-1-读书无用论与学习能力">0.1 读书无用论与学习能力</h3><ul><li><code>读书无用论</code>的本质是，学习者不具备使学习有用的能力</li><li>有些书读来是为了解决问题或者提升能力，我们称之为“<code>致用类阅读</code>”</li><li>读书需要先确定自己的目的：（<strong>从全科到分科，从笼而统之到分门别类，这是一门学问进化的必然</strong>）<ul><li>致用类图书不用在乎是否读完，作者逻辑等，而应拆为己用，联系个人经验加以运用</li><li>小说或诗集，正读或跳读都无所谓，懂或不懂也无影响，沉浸其中，物我两忘</li></ul></li></ul><span id="more"></span>>><h3 id="0-2-知识付费与学习能力">0.2 知识付费与学习能力</h3><ul><li>很多知识只是长得像知识而已。很多人也只是装作很爱学习而已</li><li>知识付费能否持续，关键在于学习能力普遍低下的状况能否得到改善</li></ul><h3 id="0-3-伪学习与真正的学习能力">0.3 伪学习与真正的学习能力</h3><ul><li>四类伪学习<ul><li>追逐各类“干货”：如20分钟音频，10分钟视频，PPT 或者 思维导图</li><li>追捧各类“大神”：听牛人分享</li><li>崇拜各种“新知”</li><li>沉迷于不解决实际问题的努力：听在线课程的数量，打卡，读书数量</li></ul></li><li>学习者需要：<ul><li>学习者是否有足够的学习能力：<strong>能运用起来</strong></li><li>学习者是否有自己的知识体系：<strong>举一反三</strong></li></ul></li></ul><h3 id="0-4-拆书法与拆书帮">0.4 拆书法与拆书帮</h3><p>拆书”是一种学习方法论，目的是学者的需求，而不是知识的学习</p><h3 id="总结">总结</h3><blockquote><p>在阅读的绝大部分情况，我们的目的都应该是我们的需求，即我们阅读（或者说学习）想要解决的问题是什么，而不应该阅读的内容教会了什么。</p></blockquote><h2 id="1-读书为什么这么难">1. 读书为什么这么难</h2><p>大多数人在读书和学习中都是遇到问题就解决问题的“<strong>头疼医头</strong>”的方式：没时间就早起；没精力就打卡；看不懂就慢慢抠；记不住就做笔记</p><blockquote><p>书本结论：如果学习者缺乏内化和应用知识的能力，即不能把知识转化成自己的能力，那么即使解决没时间、没精力、看不懂、记不住、看不下去等问题，也没有多大意义。</p></blockquote><h3 id="1-1-问题1：没时间、没精力">1.1 问题1：没时间、没精力</h3><p><code>生存余力理论模型（Margin in Life Theory）</code>：一个人总是在他需要的精力与可提供的精力之间寻求平衡。那些消耗个体精力的事情叫作**“生存负载”（Load of Life）<strong>，而处理这些负载需要</strong>“生存力量”（Power of Life）**。无论是生存负载还是生存力量，都由外部因素和内部因素构成。</p><ul><li><p>生存负载（Load of Life）</p><ul><li><strong>外部负载</strong>主要指的就是工作，包括职场工作和没有薪水的家庭工作；</li><li><strong>内部负载</strong>主要来自个体不断发展的生活期望：想买房，想换车，想升职，想40岁之前实现财务自由</li></ul></li><li><p>生存力量（Power of Life）</p><ul><li><strong>外部的力量</strong>源自家庭背景、人脉资源、经济能力;</li><li><strong>内部的力量</strong>就是个人的能力和经验</li></ul></li><li><p><strong>生存力量除以生存负载，就是麦克拉斯基强调的“生存余力”（Margin in Life）</strong></p></li></ul><p>$$<br>生存余力=\frac {生存力量}{生存负载}<br>$$</p><ul><li>对于一本书，margin过多，意味着内容过少；margin过少，读起来太累了；对于生存余力而已也是如此</li></ul><h3 id="1-2-问题2：看不懂、记不住">1.2 问题2：看不懂、记不住</h3><p><strong>看懂了，记住了，又如何？</strong></p><ul><li><strong>阅读本身也不能创造价值</strong>，理解和记忆知识都不能创造价值。</li><li><strong>改变行为才有可能创造价值</strong>。并且改变行为只发生在将读来或者听来的知识内化和反思之后</li><li>对致用类阅读来说，重要的不是看懂，而是能和自己的经验发生联系；重要的不是记住，而是能够将知识用到自己的工作和生活中</li></ul><h3 id="1-3-问题3：看不下去">1.3 问题3：看不下去</h3><ul><li>没必要读完一本书：任何一本书中（包括本书）都有很多你能学习但不需要学习的知识</li><li>读得越多，不见得用得越多</li><li><strong>价值多少跟读得多少没有关系，读得少而精反而更可能去应用</strong></li></ul><h3 id="1-4-读书的方法论">1.4 读书的方法论</h3><p><strong>为了提升生存力量，方法论必须：</strong></p><ul><li>不会成为新的生存负载</li><li>这种方法强调自我导向：以<strong>学习者为中心</strong>，而不是以书或老师为中心</li><li>致力于内化和应用知识:实现能力提升和行为改变，而不是致力于理解和记忆知识。</li></ul><h3 id="总结-2">总结</h3><blockquote><p>这一章主要是列举了日常读书（学习）中的3个主要问题：1.没时间、没精力；2.看不懂、记不住；3.看不下去。</p><p>提出了 <code>生存余力理论模型</code> ，强调一个人要从事学习活动，不许拥有一些生存余力</p><p>对于书不需要过度追求完全看懂，理解，甚至都不需要看完，读书的价值不是在于把书看懂，不是在于理解和记忆，而且是在于读书的思考，结合实际改变日常行为。即重要的是 <strong>学以致用</strong></p></blockquote><h2 id="2-从“读书”到“拆书”">2.  从“读书”到“拆书”</h2><p>拆书法的理论基础就是成人教育学，落实到“RIA方法论”，<strong>强调以学习者为中心</strong>，一定要联系学习者的经验，解决学习者的问题，提升学习者的能力。</p><p><strong>拆书法有两种实践形式</strong>：一是供个人学习的便签学习法，二是供组织学习的（由拆书家带领）RIA现场学习。</p><h3 id="2-1-有效学习的五大公理">2.1 有效学习的五大公理</h3><ul><li>自我导向<ul><li>个体成熟的标志：从依赖性人格转换为自我导向的人格</li><li>能够参与诊断自身的学习需求、规划、实施和苹果自身的学习经验</li><li>主动参与而非被动接受</li></ul></li><li>关联经验<ul><li>有效的学习应该是基于学习者的经验、充分利用学习者经验的</li></ul></li><li>强调实践<ul><li>能力水平和意愿水平的组合，被称作个体做此事的“准备度”</li><li>选择学习内容时，首先要考虑“是否用得上”，</li><li>判断学习效果的标准要考虑“是否用上了”</li></ul></li><li>聚焦于解决实际问题<ul><li>以解决实际问题为目标的学习</li></ul></li><li>内在驱动<ul><li>成人学习更多的是受到内在因素（希望解决问题、提升能力和自我实现）而非外在因素（如考试、考核、证书）的驱动</li></ul></li></ul><h3 id="2-2-RIA-阅读拆页-讲解引导-拆为己用">2.2 RIA=阅读拆页+讲解引导+拆为己用</h3><ul><li><p><code>R（Reading，阅读拆页）</code>，拆书家请学习者阅读原书拆页。</p></li><li><p><code>I（Interpretation，讲解引导）</code>，拆书家讲解引导，促进学习者理解知识并关联自己。</p></li><li><p><code>A（Appropriation，拆为己用）</code>，拆书家催化促动，促进学习者将书中内容拆为己用。</p><ul><li>A1 反思经验</li><li>A2 规划应用</li><li>A3 现场演练</li></ul></li></ul><h3 id="2-3-片面追求“干货”是一种“病”">2.3 片面追求“干货”是一种“病”</h3><ul><li><p><strong>知识并不值钱</strong></p><ul><li>在《经济学原理》中提到，<strong>一个人对任何一种物品的支付愿望都基于其边际利益，即物品产生的额外利益。反过来，边际利益又取决于一个人拥有多少这种物品。</strong>，</li><li>知识，本身很好、很重要，但是在信息时代，额外得到一份知识太容易了，其边际利益被大大降低，所以知识是好东西，但不值钱</li></ul></li><li><p>案例很重要</p><ul><li>恰当的案例可以帮助学习者领悟相关知识的适用边界</li><li>干货脱去的是帮助学习者内化和应用的东西，留下最不值钱的核心知识</li></ul></li><li><p>自己读书时怎么做</p><ul><li>便签读书法</li></ul></li><li><p>拆书法有两种实践形式：供个人学习的便签学习法和供组织学习的RIA现场学习</p></li></ul><h3 id="总结-3">总结</h3><blockquote><p>拆书法是一种成人教育理论，落在到RIA方法论。</p><p>R 阅读拆页（拆出部分内容阅读）</p><p>I 讲解引导</p><p>A 拆为己用（A1 反思经验； A2 规划应用；A3 现场演练）</p></blockquote><h2 id="3-学习者的不同境界">3. 学习者的不同境界</h2><h3 id="3-1-你是哪类学者">3.1 你是哪类学者</h3><ul><li><p>初级学习者的特征</p><ul><li>书本当作权威</li><li>把浏览知识的数量当作学习的收获</li><li>读书当成一件高尚的、纯粹的、脱离了低级趣味的事</li></ul></li><li><p>高级学习者的特征</p><ul><li>先判断学习的目标、读书的类型。对于知识类学习，他们把书当老师</li><li>把致用类图书当医生</li><li>学会了不对书负责，而只负责解决自己的问题、提升自己的能力：学习&lt;–&gt;复盘</li><li>从不抱怨自己的知识储备太少</li></ul></li><li><p>学习促进者的特征</p><ul><li>通过教会别人而深刻掌握某个知识</li><li>把相关知识拆为己用，同时自己的学习能力、沟通能力和思维能力也能不断得到强化</li></ul></li></ul><h3 id="3-2-如何正确地提问？">3.2 如何正确地提问？</h3><ul><li>我们提问的时候，要想方设法提出能真正从中学习的问题。</li><li>在回答别人（孩子、学生、下属等）的提问时，提醒他不要太关注正确答案，促进他思考自己的提问</li><li>高级学习者怎么提问<ul><li>一种提问是为了得到正确答案；另一种提问是为了进行有效学习。前者常问“是什么”“为什么”，后者常问“如何”“你都考虑哪些方面”</li><li>善于学习的人在反思和追问时，会尽量用“如何”来取代“为什么”</li><li>善于学习的人还习惯在标准的层面向对方提问。不是问对方如何看待当下这件事，而是问对方面对这类事务时都考虑哪些因素；</li></ul></li><li>学习促进者怎么回答提问<ul><li>一种回答是能够给出正确答案，另一种回答是能够促进正确思考。</li><li>扼杀问题的最大凶手是什么？不是粗暴的打断，而是正确的答案。</li></ul></li></ul><h3 id="总结-4">总结</h3><blockquote><p>学会提问，在面对别人的问题时，学会提问让他去思考发现答案；面对学习和阅读时，学会提问自己来达到学以致用</p></blockquote><h2 id="4-便签学习法：培养全新的思维模式">4. 便签学习法：培养全新的思维模式</h2><p>便签法的基本应用</p><h3 id="4-1-明确目标：提升学习力">4.1 明确目标：提升学习力</h3><p>便签法的目标是用最简单的工具和方法提高职场人的学习效果和学习能力</p><h3 id="4-2-拆解原则：反求诸己">4.2 拆解原则：反求诸己</h3><ul><li>原则<ul><li>自我导向</li><li>让书对你负责（学习者为中心）</li><li>应用</li><li>采用简单的工具：便签</li></ul></li></ul><h3 id="4-3-随处可见的辅助工具">4.3 随处可见的辅助工具</h3><ul><li>使用三种不同颜色的便签，分别用来做3类笔记（I、A1、A2）：<ul><li>第1类拆解（I）：用自己的语言重述信息。</li><li>第2类拆解（A1）：描述自己的相关经验。</li><li>第3类拆解（A2）：我的应用（目标与行动）</li></ul></li><li>一组多色指示标签</li><li>一支笔</li></ul><h3 id="4-4-“拆书”七步曲">4.4 “拆书”七步曲</h3><ul><li>第一步，确定你要读的是<strong>致用类的图书</strong>，这是拆书法的<strong>适用边界</strong></li><li>第二步，快速阅读，遇到重点提问：这对我有多重要？</li><li>第三步，在I便签上用自己的语言简要重述相关信息，也可以是总结自己得到的启发、有价值的提醒。写好后贴在相应的书页。</li><li>第四步，针对书中的某个信息，问问自己有没有相关的经历，是否听说或者见到过类似的事情，写在一张 A1 便签上，贴到I便签旁边。</li><li>第五步，规划今后如何应用。尽量先考虑应用的目标，再写下达到目标应实施的行动。写在一张 A2 便签上，也贴在书页上。</li><li>第六步，在贴了便签的书页旁，贴一张指示标签。提醒自己这一页有自己的学习资料。</li><li>第七步，看完一本书后，把所有的 A2 便签拿出来贴在冰箱或墙上，提醒自己落实行</li></ul><h3 id="4-5-便签使用贴士">4.5 便签使用贴士</h3><ul><li><p>第一点，若原书内容简明易懂，则可以不用I便签，只需在重点内容下面加下划线或在侧面加边划线就可以。</p></li><li><p>第二点，想好再写，要有的放矢，而不是笔底生花，内容请尽量控制在一张便签之内。有时I便签和A1便签上的文字会较多，那么可以再加一张便签。为了避免感慨内容泛滥，A2便签尽可能清晰、精练。如果你想到3个应用点或行动计划（每个行动都要对应一个目标），那么就写3张A2便签吧。</p></li><li><p>第三点，指示标签的作用相当于升级版书签，用于提醒自己哪几页贴过便签。尤其是你拿出A2便签之后，可能过一段时间又希望把贴在墙上的A2便签再放回书里。鼓励你尝试一套适合自己的标签使用规则，比如黄色指示标签表示这一页便签对我非常有价值，绿色指示标签表示要尽快行动，橙色指示标签意味着需要再次加工便签……</p></li></ul><h3 id="4-6-切勿陷入误区">4.6 切勿陷入误区</h3><p><strong>I：重述知识的标准</strong></p><ul><li>1.诠释：基本用自己的语言，不直接引用原文语句。</li><li>2.准确：对原文相关知识点解读准确。</li><li>3.清晰：逻辑清晰，文字精练。</li><li>4.致用：将原文知识点总结或加工成具体的操作方法或建议步骤。</li></ul><p><strong>I便签常见误区：附会旧知</strong></p><ul><li>这种“不就是××嘛”的反应</li><li>对着你写下的I便签问问自己：若是没读那段原文的话，I便签写下的这些我知不知道？如果答案是“我早就知道”，那你很可能就是在用旧知附会新知了。</li></ul><hr><p><strong>A1：内化知识的标准</strong></p><ul><li>1.鲜活：是自己亲身经历的，亲眼所见、亲耳所闻的认知。</li><li>2.故事：相关叙事要素基本完整，能够清晰地体现出起因和结果。</li><li>3.对应：和原文或I便签的4个要素对应，使之成为贴切的案例。</li><li>4.反思：无论想到的是成功还是失败的经验，都能帮助自己更深入地理解这个经验，也加深了对原文信息的认知。</li></ul><p><strong>A1便签常见误区：泛泛而谈</strong></p><ul><li>泛泛而谈，不讲具体事例</li></ul><hr><p><strong>A2：应用知识的标准</strong></p><ul><li>1.目标：是否规划了目标？目标是否符合SMART法则[插图]？</li><li>2.行动：行动是否可以拉近现状与目标的距离？具体行动步骤如何？行动人是谁？在哪里？行动何时开始？频率如何？</li><li>3.关联：是否使用了原文信息或I便签的方法。</li><li>4.可控：都是自己能做到或能推动他人做到的吗？可以量化做的程度吗？行动显性化吗？</li></ul><p><strong>A2便签常见误区：决心泛滥或感慨万千</strong></p><ul><li>在写A2便签前，应该先定目标。实现目标是对行动的最佳奖赏</li><li>参考SMART法则。</li></ul><hr><p><code>便签法的微信训练法</code></p><p>在接下来的1个月内，严格要求自己不能在朋友圈里直接转发任何内容。当你在微信订阅号、朋友圈或某个群看到一篇不错的文章想要转发时，让自己停下来，问问自己：</p><p>我能加上自己的重述再转发吗？</p><p>重述的时候能体现一下前因后果或适用边界吗？</p><p>我能补充点儿自己的相关经验吗？</p><p>我能加上一个自己的应用或行动吗？</p><p>只要能想到或加上一点儿自己的东西，那你就得到了锻炼。如果对着手机想5分钟还是想不到呢？实在想不出来就放弃转发吧，这篇文章跟你的关系没那么大。同时，那5分钟也没有浪费，在这期间你的大脑得到了高效练习，对应I、A1、A2的思维肌肉也得到了强化训练</p><h3 id="总结-5">总结</h3><blockquote><p>便签法的简单实用，在阅读过程中，对自己有用的知识进行一下三步操作：</p><ul><li>第1类拆解（I）：用自己的语言重述信息。</li><li>第2类拆解（A1）：描述自己的相关经验。</li><li>第3类拆解（A2）：我的应用（目标与行动）</li></ul></blockquote><h2 id="5-打造学习力的三个维度">5. 打造学习力的三个维度</h2><p>便签法的升级，学习能力从一维（内化与应用知识）拓展到三维（怎么在移动阅读中学习，通过经验学习）</p><h3 id="5-1-学习力是元能力">5.1 学习力是元能力</h3><p>无论能力的谱系多么复杂，有一项能力是最特殊的，那就是学习能力。因为学习能力是元能力——关于能力的能力</p><h3 id="5-2-解读知识：为信息添加上下文">5.2 解读知识：为信息添加上下文</h3><ul><li>所有知识都算信息，但并非所有的信息都是知识</li><li>知识的结构化比较清晰，具备“可证伪性”，鼓励受众自己判断<ul><li>一天要喝8杯水</li><li>在肾功能没有问题的前提下，一位成年人一天喝2 000毫升水对身体有益</li></ul></li></ul><hr><p><strong>信息进行分析和整理</strong></p><p>**分析：**分析信息对自己的重要程度，以便决定是否学习</p><p>**整理：**将信息结构化，以便形成知识</p><ul><li><p><strong>分析信息</strong>的关键是追问前因后果</p><ul><li>前（前车可鉴）：为什么这件事对我重要？作者是怎么引出这个信息的？</li><li>因（相因相生）：作者提出了哪些关于原因的假设？是怎么验证或排除这些假设的？还有其他可能性吗？</li><li>后（以观后效）：若依从信息去做之后会怎样？对我的好处（效用）是什么？</li><li>果（自食其果）：不这么做的后果是什么？不改变的问题有多严重？</li></ul></li><li><p><strong>整理信息</strong>的关键是明确适用边界</p><ul><li>适（适得其反）：有没有相反的观点？有没有不支持这个观点的实例？</li><li>用（使用条件）：要这样做得具备哪些条件（考虑成本收益，考虑态度能力……）？什么情况下是不管用的？</li><li>边（旁敲边鼓）：从前有没有类似的（或看起来差不多的）信息？其他领域/行业/作者如何看待类似的问题？</li><li>界（楚河汉界）：无论是相反的还是类似的信息，和这个信息的真正区别是什么？交界在哪里？</li></ul></li></ul><h3 id="5-3-I便签：辨别知识和信息">5.3 I便签：辨别知识和信息</h3><p>升级 I便签，由<code>重述知识的标准</code> 升级为<code>辨别知识和信息</code>（需要尽量在I便签中刻意体现你对信息的前因后果和适用边界的思考）</p><h3 id="5-4-不要急于质疑和挑战">5.4 不要急于质疑和挑战</h3><ul><li>遇到新信息时，在分析阶段（问前因后果）主要<strong>关注信息的有用</strong>、有价值之处，到了整理阶段（问适用边界）<strong>再去质疑和挑战</strong>。</li><li>看书比看手机更容易有收获，并不是因为书中信息更好、更正确或更系统，而是书中的内容能更有效地帮学习者理清前因后果和适用边界</li></ul><h3 id="5-5-如何借助A1、A2便签来追问和反思？">5.5 如何借助A1、A2便签来追问和反思？</h3><ul><li>对成人学习来说，学习的起点往往是因为遇到了问题</li><li>有些问题，前因后果千差万别，没有一本书能提供现成的答案；适用边界因人而异，不可能有人给出解决方案</li><li>从知识或信息中学习（即<code>Knowledge</code>，称为K机制）并非人类学习的唯一机制，学习的另一维度是从经验中学习（即<code>Experience</code>，称为E机制）。</li><li>学习的最高境界是“知行合一”：<code>知之真切笃行处即是行，行之明觉精察处即是知</code></li></ul><hr><p><strong>经验学习圈模型</strong></p><blockquote><p><code>经验学习圈模型</code>：学习的起点是人们的经验（<code>Experience</code>）,然后是对经验进行反思（<code>Reflection</code>），再系统化和理论化反思的结果，也就是学习的第三阶段——“理论化”（<code>Theorization</code>），最后是“行动”（<code>Action</code>）。行动中如果出现新问题，则开始又一轮的学习圈，如此循环。</p></blockquote><pre><code class="language-mermaid">graph TB;A(经验 Experience)--&gt;B(反思 Reflection)B --&gt; C(理论化 Theorization)C --&gt; D(行动 Action)D --&gt; A</code></pre><p><strong>便签法实现经验学习圈模型</strong></p><ul><li>A1便签：写下自己的问题，然后对这个问题进行反思和追问，问有洞察力的问题<ul><li>如前因后果、适用边界</li><li>一定是自己亲历的问题，不能是想象的、理论的问题</li><li>比较紧迫或重要的问题</li><li>简短一点</li></ul></li><li>I便签： 写下A1标签追问后重新定义的问题<ul><li>对A1反思和追问，把“真正需要解决的问题”写在I便签上</li><li>I便签用以重述信息，其实是为了澄清问题、理解问题、找到根源，从而重新定义问题。</li></ul></li><li>A2便签：规划并行动<ul><li>目标性、行动性、关联性、可控性</li></ul></li><li>在 A2 落实过程中，遇到问题继续冲 A1 开始，不断循环</li></ul><p>有洞察力的问题总是需要不同的视角和不同的假设。如果你实在没有思路，可以从如下8类提问开始：</p><ul><li><p>追问前因后果</p><ul><li>前（前车可鉴）：为什么这件事对我重要？是怎么出现这个问题的？</li><li>因（相因相生）：都有哪些关于原因的假设？怎么验证或排除这些假设？还有其他人能帮我思考，给出更多选择或可能性吗？</li><li>后（以观后效）：若这个问题解决了，最好的结果是什么？那是我期待的吗？</li><li>果（自食其果）：如果我什么都不做，会发生什么？</li></ul></li><li><p>明确适用边界</p><ul><li>适（适得其反）：有没有人不同意我对原因的假设？有没有不符合这个假设的实例？</li><li>用（使用条件）：要解决这个问题，需要具备哪些条件（考虑成本收益，考虑态度能力……）？这件事可以用其他什么方式来完成？</li><li>边（旁敲边鼓）：有没有可供借鉴的情况？其他领域/行业/人如何解决类似问题？</li><li>界（楚河汉界）：无论是不同的意见还是类似的问题，它们和我的思路的真正区别是什么？交界在哪里？</li></ul></li></ul><h3 id="总结-6">总结</h3><blockquote><p>升级便签法：</p><p>从A1开始，明确问题，反思并重定义问题记录为I，在A2落实行动，遇到问题继续中A1开始。</p></blockquote><h2 id="6-构建属于你自己的知识体系">6. 构建属于你自己的知识体系</h2><p>一组便签到多组便签，相互配合、相互对接、相互界定，你的知识体系自然会生长</p><h3 id="6-1-知识管理：被加工的碎片化信息">6.1 知识管理：被加工的碎片化信息</h3>]]></content>
    
    
    <summary type="html">&lt;h1&gt;这样读书就够了&lt;/h1&gt;
&lt;h2 id=&quot;0-引言&quot;&gt;0. 引言&lt;/h2&gt;
&lt;h3 id=&quot;0-1-读书无用论与学习能力&quot;&gt;0.1 读书无用论与学习能力&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;读书无用论&lt;/code&gt;的本质是，学习者不具备使学习有用的能力&lt;/li&gt;
&lt;li&gt;有些书读来是为了解决问题或者提升能力，我们称之为“&lt;code&gt;致用类阅读&lt;/code&gt;”&lt;/li&gt;
&lt;li&gt;读书需要先确定自己的目的：（&lt;strong&gt;从全科到分科，从笼而统之到分门别类，这是一门学问进化的必然&lt;/strong&gt;）
&lt;ul&gt;
&lt;li&gt;致用类图书不用在乎是否读完，作者逻辑等，而应拆为己用，联系个人经验加以运用&lt;/li&gt;
&lt;li&gt;小说或诗集，正读或跳读都无所谓，懂或不懂也无影响，沉浸其中，物我两忘&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="note" scheme="https://xuzhuohao.github.io/categories/note/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM内存管理</title>
    <link href="https://xuzhuohao.github.io/2020/12/28/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://xuzhuohao.github.io/2020/12/28/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-12-28T11:42:36.000Z</published>
    <updated>2021-03-29T02:52:58.963Z</updated>
    
    <content type="html"><![CDATA[<h1>jvm 内存管理</h1><h2 id="1-Java内存区域与内存溢出异常">1. Java内存区域与内存溢出异常</h2><h3 id="1-1-运行时数据区域">1.1 运行时数据区域</h3><p>对于运行时数据区域被划分为5个区域，<em><strong>方法区（Method Area）</strong></em> ,<strong>虚拟机栈（VM Stack）</strong>, <strong>本地方法栈（Native Method Stack)</strong>, <em><strong>堆（Heap）</strong></em>，<strong>程序计数器（Program Counter Register)</strong></p><p>方法区 和 堆 由所有线程共享，其他是线程隔离的。</p><h4 id="1-1-1-程序计数器">1.1.1 程序计数器</h4><p><strong>当前线程所执行的字节码的行号指示器</strong></p><ul><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li>Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，所以需要每个线程独立存储自己的指示器</li><li>线程执行Java方法时，这个计数器记录的是正在执行的虚拟机字节码指令的地址；</li><li>线程执行的是本地（Native）方法，这个计数器值则应为空（Undefined）</li></ul><span id="more"></span> >><h4 id="1-1-2-Java虚拟机栈">1.1.2 Java虚拟机栈</h4><p><strong>虚拟机栈描述的是Java方法执行的线程内存模型</strong></p><ul><li>Java虚拟机都会同步创建一个<strong>栈帧</strong>（Stack Frame）用于存储<strong>局部变量表、操作数栈、动态连接、方法出口</strong>等信息。</li><li>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</li><li>局部变量表：<ul><li>存放<strong>Java虚拟机基本数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和r<strong>eturnAddress类型</strong>（指向了一条字节码指令的地址）</li><li>局部变量表中的存储空间以**局部变量槽（Slot）**来表示</li><li>局部变量表在<strong>编译期间完成空间分配</strong>，在方法运行期间<strong>不会改变局部变量表的大小（slot的数量，而slot的大小又虚拟机决定）</strong></li></ul></li><li><strong>线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</strong>；</li><li><strong>Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常</strong></li></ul><h4 id="1-1-3-本地方法栈">1.1.3 本地方法栈</h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用类似，只是虚拟机栈为虚拟机<strong>执行Java方法（也就是字节码）服务</strong>，而本地方法栈则是为虚拟机使用到的<strong>本地（Native）方法服务</strong>。</p><ul><li><strong>本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常</strong></li></ul><h4 id="1-1-4-Java堆">1.1.4 Java堆</h4><ul><li>Java堆（Java Heap）是虚拟机所管理的<strong>内存中最大的一块</strong></li><li><strong>所有线程共享，在虚拟机启动时创建</strong></li><li>目的就是存放对象实例</li><li>Java堆是<strong>垃圾收集器管理的内存区域</strong>，因此一些资料中它<strong>也被称作“GC堆”</strong>（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）</li><li>所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。</li><li>Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的</li><li>如果在Java堆中<strong>没有内存完成实例分配，并且堆也无法再扩展时</strong>，Java虚拟机将会抛出OutOfMemoryError异常。</li></ul><h4 id="1-1-5-方法区">1.1.5 方法区</h4><p><strong>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</strong></p><ul><li>这区域的内存回收目标主要是针对常量池的回收和对类型的卸载</li><li><strong>方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常</strong></li></ul><h5 id="1-1-5-1-运行时常量池">1.1.5.1 运行时常量池</h5><p><strong>运行时常量池（Runtime Constant Pool）是方法区的一部分</strong></p><ul><li>类加载后，会从类中加载**编译期生成的各种字面量与符号引用(class文件中)**到方法区的运行时常量池中</li><li>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性</li><li>运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</li><li>当常量池无法再申请到内存时会抛出OutOfMemoryError异常</li></ul><h5 id="1-1-5-2-直接内存">1.1.5.2 直接内存</h5><ul><li>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</li><li>本机直接内存的分配不会受到Java堆大小的限制</li></ul><h3 id="1-2-HotSpot虚拟机对象探秘">1.2 HotSpot虚拟机对象探秘</h3><h4 id="1-2-1-对象的创建">1.2.1 对象的创建</h4><pre><code class="language-mermaid">graph TD1[new] --&gt; 2&#123;指令参数能否&lt;br&gt;在常量池中定位到&lt;br&gt;一个类的符号引用&#125;2 --&gt;|能| 3&#123;检查是否已经被&lt;br&gt;加载解析和初始化&#125;2 --&gt;|不能| 4[加载过程]3 --&gt;|已完成| 5[分配内存]3 --&gt;|未完成| 44 --&gt; 55 --&gt; 6[初始化零值]6 --&gt; 7[设置对象信息如对象头等]7 --&gt; 8(加载完成)8 --&gt; 9[init]</code></pre><ul><li>在堆上分配内存（空间问题）<ul><li>堆内存是规整的：采用**“指针碰撞”（Bump The Pointer）**的分配方式</li><li>堆内存不规整的：采用**“空闲列表”（Free List）**的分配方式</li><li>堆内存的规整与否，由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定</li><li>Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；</li><li>而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存</li></ul></li><li>在堆上分配内存（同步问题）<ul><li>一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；</li><li>另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）</strong>，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，<strong>分配新的缓存区时才需要同步锁定</strong>。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定</li></ul></li><li>虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为<strong>零值</strong>，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。<strong>保证能使用零值</strong></li><li>Java虚拟机还要对对象进行必要的设置</li><li><strong>从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数</strong></li></ul><h4 id="1-2-2-对象的内存布局">1.2.2 对象的内存布局</h4><p>对象在堆内存中的存储布局可以划分为三个部分：<strong>对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</strong></p><h5 id="1-2-2-1-对象头">1.2.2.1 对象头</h5><ul><li>存储对象自身的运行时数据：<strong>Mark Word</strong><ul><li>哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</li></ul></li><li>对象头的另外一部分是类型指针：<strong>Klass Point</strong><ul><li>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li><li><strong>但是</strong>，查找对象的元数据信息并不一定要经过对象本身</li></ul></li></ul><h5 id="1-2-2-2-实例数据">1.2.2.2 实例数据</h5><p><strong>对象真正存储的有效信息</strong>,即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来</p><ul><li>存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响<ul><li>HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs）</li><li>HotSpot虚拟机的+XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间</li></ul></li></ul><h5 id="1-2-2-3-对齐填充">1.2.2.3 对齐填充</h5><p><strong>不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用</strong></p><blockquote><p>HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全</p></blockquote><h4 id="1-2-3-对象的访问定位">1.2.3 对象的访问定位</h4><p><strong>Java程序会通过栈上的reference数据来操作堆上的具体对象</strong></p><ul><li>主流的访问方式主要有使用<strong>句柄</strong>和<strong>直接指针</strong>两种：<ul><li>句柄：堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息</li><li>直接指针：Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址（HotSpot 使用的方式）</li><li>句柄稳定，而直接指针开销少</li></ul></li></ul><h3 id="1-3-OutOfMemoryError-异常检查">1.3 OutOfMemoryError 异常检查</h3><h4 id="1-3-1-Java堆溢出">1.3.1 Java堆溢出</h4><ul><li><p>堆溢出：</p><ul><li>不断创建对象</li><li>使创建的对象保持GC Root 可达</li><li>java.lang.OutOfMemoryError:Java heap space</li><li>通过参数**-XX：+HeapDumpOnOutOf-MemoryError**可以让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照以便进行事后分析</li></ul></li><li><p>简要检查步骤：</p><ul><li>到底是出现了<strong>内存泄漏（Memory Leak）<strong>还是</strong>内存溢出（Memory Overflow）</strong></li><li>内存泄漏：查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联</li><li>内存溢出：检查Java虚拟机的堆参数（-Xmx与-Xms）设置</li></ul></li></ul><h4 id="1-3-2-虚拟机栈和本地方法栈溢出">1.3.2 虚拟机栈和本地方法栈溢出</h4><ul><li>溢出原因：<ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li><li>如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。</li></ul></li><li>溢出场景：<ul><li>使用-Xss参数减少栈内存容量</li><li>定义了大量的本地变量，增大此方法帧中本地变量表的长度</li></ul></li><li>检查：<ul><li>出现StackOverflowError异常时，会有明确错误堆栈可供分析，相对而言比较容易定位到问题所在</li></ul></li></ul><h4 id="1-3-3-方法区和运行时常量池溢出">1.3.3 方法区和运行时常量池溢出</h4><ul><li><p>溢出原因（常量池）：</p><ul><li>JDK 6 之前包括JDK 6<ul><li>JDK 6 之前包括JDK 6 的HotSpot虚拟机中，常量池都是分配在永久代中，可以通过-XX：PermSize和-XX：MaxPermSize限制永久代的大小，即可间接限制其中常量池的容量</li><li>OutOfMemoryError:PermGen space</li></ul></li><li>JDK 7或更高版本的JDK<ul><li>JDK 7中的-XX：MaxPermSize，JDK 8及以上的-XX：MaxMeta-spaceSize 命令限制方法区容量，也都不会重现JDK 6中的溢出异常</li><li><strong>自JDK 7起，原本存放在永久代的字符串常量池被移至Java堆之中</strong></li></ul></li></ul></li><li><p>溢出原因（方法区）</p><ul><li>大量的类去填满方法区，直到溢出为止</li></ul></li><li><p>异常场景：</p><ul><li>大量的常量</li><li>使用到CGLib这类字节码技术，当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存</li></ul></li></ul><blockquote><p>JDK 8以后，<strong>永久代便完全退出了历史舞台</strong>，<strong>元空间</strong>作为其替代者登场。在默认设置下，前面列举的那些正常的动态创建新类型的测试用例已经<strong>很难再迫使虚拟机产生方法区的溢出异常了</strong></p><p>-XX：MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说<strong>只受限于本地内存大小</strong>。·</p><p>-XX：MetaspaceSize：<strong>指定元空间的初始空间大小，以字节为单位</strong>，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX：MaxMetaspaceSize（如果设置了的话）的情况下，适当提高该值。</p><p>-XX：MinMetaspaceFreeRatio：作用是**在垃圾收集之后控制最小的元空间剩余容量的百分比，**可减少因为元空间不足导致的垃圾收集的频率。类似的还有-XX：Max-MetaspaceFreeRatio，用于控制最大的元空间剩余容量的百分比。</p></blockquote><h4 id="1-3-4-本机直接内存溢出">1.3.4 本机直接内存溢出</h4><p><strong>直接内存（Direct Memory）的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值（由-Xmx指定）一致</strong></p><ul><li>检查：<ul><li>直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况</li><li>如果内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了 DirectMemory（典型的间接使用就是NIO），那就可以考虑重点检查一下直接内存方面的原因了</li></ul></li></ul><h2 id="2-垃圾收集器与内存分配策略">2. 垃圾收集器与内存分配策略</h2><ul><li><p>哪些内存需要回收？</p></li><li><p>什么时候回收？</p></li><li><p>如何回收？</p></li></ul><h3 id="2-1-对象是否存活">2.1 对象是否存活</h3><h4 id="2-1-1-引用计数算法（Reference-Counting）">2.1.1 引用计数算法（Reference Counting）</h4><p>在对象中添加一个引用计数器，每当有一个地方<strong>引用它时，计数器值就加一</strong>；当引用<strong>失效时，计数器值就减一</strong>；</p><ul><li><p>优势</p><ul><li>原理简单</li><li>判定效率高</li></ul></li><li><p>问题（为什么 java 没有使用引用计数器）</p><ul><li>必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题，如一下代码，objA 和 objB 其实都是可以回收的，但是他们之间还是存在引用</li></ul></li></ul><pre><code class="language-java">TestGc objA = new TestGc();TestGc objB = new TestGc();objA.instance = objB;objB.instance = objA;objA = null;objB = null;System.gc();</code></pre><h4 id="2-1-2-可达性分析算法（Reachability-Analysis）">2.1.2 可达性分析算法（Reachability Analysis）</h4><p>这个算法的基本思路就是通过一系列称为**“GC Roots”的根对象作为起始节点集**，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为**“引用链”（Reference Chain）<strong>，如果</strong>某个对象到GC Roots间没有任何引用链相连**，或者用图论的话来说就是从<strong>GC Roots到这个对象不可达时</strong>，则证明此对象是不可能再被使用的。</p><ul><li>固定可作为GC Roots的对象包括以下几种<ul><li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li><li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li><li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li></ul></li></ul><p><strong>根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。</strong></p><h4 id="2-1-3-再谈引用">2.1.3 再谈引用</h4><p>java 中引用的传统定义导致引用只有“被引用”或者“未被引用”两种状态，JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为**强引用（StronglyRe-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）**4种，</p><ul><li><strong>强引用</strong>：<ul><li>显式声明：Obj A = new Obj()</li><li><strong>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</strong></li></ul></li><li><strong>软引用</strong>：还有用，但非必须的对象<ul><li>使用 SoftReference 类来实现软引用</li><li><strong>系统将要发生内存溢出异常前被回收</strong></li></ul></li><li><strong>弱引用</strong>：非必须对象<ul><li>使用 WeakReference 类来实现弱引用</li><li><strong>发生GC时被回收，无论是否内存溢出</strong></li></ul></li><li><strong>虚引用</strong>：<ul><li>使用 PhantomReference 类来实现虚引用</li><li>对象设置虚引用关联的唯一目的只是为了能在这个对象<strong>被收集器回收时收到一个系统通知</strong></li></ul></li></ul><h4 id="2-1-4-对象是否存活？">2.1.4 对象是否存活？</h4><p><strong>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的</strong></p><pre><code class="language-mermaid">graph TD1[可达性分析] --&gt; 2&#123;是否有引用链&#125;2 --&gt;|有|3(end)2 --&gt;|没有|4&#123;是否要执行&lt;br&gt;finalize方法&#125;4 --&gt; |没有覆盖finalize方法&lt;br&gt;已经被调用过&lt;br&gt;没必要执行finalize|5(回收对象)4 --&gt; |有必要执行finalize方法|6[对象置入F-Queue的队列]6 --&gt; 7(*)7 --&gt; 8[在Finalizer中重新建立引用&lt;br&gt;使GC可达&lt;br&gt;避免被回收]t1(*) --&gt; t2[由虚拟机自动建立的&lt;br&gt;低调度优先级的&lt;br&gt;Finalizer线程]t2 --&gt; t3[执行F-Queue中&lt;br&gt;对象的Finalizer方法]t3 --&gt; t4[不承诺一定会等待它运行结束]t4 --&gt; t5(end)</code></pre><p>在finalizer()中重新被引用，<strong>可能（finalizer()不一定被执行）<strong>可以避免被回收，前提得在二次标记之前执行 finalizer()，所以对象在</strong>执行了 finalizer() 之后不一定被回收</strong></p><p>而任何一个对象的 <strong>finalize() 方法都只会被系统自动调用一次</strong>，如果对象面临下一次回收，它的finalize()方法不会被再次执行</p><blockquote><p>finalize()的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。</p><p>建议完全可以忘掉Java语言里面finalize()的这个方法</p></blockquote><h4 id="2-1-5-回收方法区">2.1.5 回收方法区</h4><p>主要回收两部分内容：<strong>废弃的常量和不再使用的类型</strong></p><ul><li>回收废弃常量与回收Java堆中的对象非常类似<ul><li>虚拟机中也没有其他地方引用这个字面量</li></ul></li><li>判定一个类型是否属于“不再被使用的类”的条件就比较苛刻<ul><li>条件：<ul><li>该类所有的实例都已经被回收：Java堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收：这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul></li><li>满足上述三个条件的无用类也只是允许被回收<ul><li>HotSpot虚拟机提供了-Xnoclassgc参数进行控制</li><li>可以使用-verbose：class以及-XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息</li><li>-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用</li><li>-XX：+TraceClassUnLoading参数需要FastDebug版的虚拟机支持</li></ul></li></ul></li></ul><h3 id="2-2-垃圾收集算法">2.2 垃圾收集算法</h3><p>细节方面，可以阅读RichardJones撰写的《垃圾回收算法手册》的第2～4章的相关内容</p><p>垃圾收集算法可以划分为**“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”**（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。</p><h4 id="2-2-1-分代收集理论">2.2.1 分代收集理论</h4><ul><li><p>两个分代假说</p><ul><li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li><li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡</li></ul></li><li><p>隐含的假说： 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</p></li><li><p>收集概念</p><ul><li>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<ul><li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li><li>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。</li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li><li>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集</li></ul></li></ul></li></ul><h4 id="2-2-2-标记-清除算法（Mark-Sweep）">2.2.2 标记-清除算法（Mark-Sweep）</h4><p><strong>最早出现也是最基础的垃圾收集算法</strong></p><ul><li><p>算法分为“标记”和“清除”两个阶段：</p><ul><li>标记出所有需要回收的对象，</li><li>统一回收掉所有被标记的对象</li></ul></li><li><p>也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p></li><li><p><strong>标记过程就是对象是否属于垃圾的判定过程</strong></p></li><li><p>缺点</p><ul><li>执行效率不稳定</li><li>内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li></ul></li></ul><h4 id="2-2-3-标记-复制算法（半区复制：SemispaceCopying）">2.2.3 标记-复制算法（半区复制：SemispaceCopying）</h4><p>内存分为两块大小一样的区域，用以标记出需要回收对象后，把不用被回收的对象负责到半区中，然后清除原来半区的数据。</p><ul><li><p>优点是清除效率提高了，也不存在空间碎片化问题</p></li><li><p>缺点是空间利用率变低，只有原来的一般</p></li><li><p><strong>Java虚拟机大多都优先采用了这种收集算法去回收新生代</strong></p></li></ul><h5 id="2-2-3-1-Appel式回收">2.2.3.1 Appel式回收</h5><blockquote><p>Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。</p></blockquote><ul><li><p>新生代分为一块较大的 Eden 空间 和两块较小的 Survivor 空间 （HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1）</p></li><li><p>每次分配内存只使用Eden和其中一块Survivor</p></li><li><p>发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性<strong>复制</strong>到另外一块Survivor空间上，然后直接<strong>清理</strong>掉Eden和已用过的那块Survivor空间</p></li><li><p>当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）</p></li></ul><p><strong>默认以8:1来分配新生代空间，会得到 80%的 Eden 一个，10%的 Survivor 两个，其中 Eden 和一个 Survivor 充电新生代的作用，而剩下的 Surivivor 充当复制区，当存活的对象在复制区中放置不下时，一般会被放到老年代中</strong></p><h4 id="2-2-4-标记-整理算法（Mark-Compact）">2.2.4 标记-整理算法（Mark-Compact）</h4><p>其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向内存空间一端移动</strong>，然后直接清理掉边界以外的内存</p><ul><li><p>移动则内存回收时会更复杂，不移动则内存分配时会更复杂。</p></li><li><p>从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。</p></li><li><p>HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的，这也从侧面印证这点</p></li></ul><h3 id="2-3-HotSpot的算法细节实现">2.3 HotSpot的算法细节实现</h3><p><strong>粗劣记录</strong></p><ul><li><p>根节点枚举</p><ul><li>OopMap（普通对象指针（OrdinaryObject Pointer，OOP））</li></ul></li><li><p>安全点（Safepoint）</p><ul><li>“特定的位置”生成OopMap，这些位置被称为安全点</li><li>如何停下所有线程<ul><li>抢先式中断（Preemptive Suspension）：首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在<strong>几乎没有</strong>虚拟机实现采用抢先式中断来暂停线程响应GC事件</li><li>主动式中断（Voluntary Suspension）：设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起</li></ul></li></ul><blockquote><p>HotSpot使用内存保护陷阱的方式，虚拟机把某一位的内存页设置为不可读，那线程执行到对应指令时就会产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待</p></blockquote><ul><li>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点</li></ul></li><li><p>安全区域</p><ul><li>用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己</li><li>增加安全区域，线程声明自己进入安全区域后，垃圾回收时就不会管它们了</li></ul></li><li><p>记忆集与卡表（Remembered Set）</p><ul><li>新生代中建立了名为记忆集的数据结构，用以避免把整个老年代加进GC Roots扫描范围</li></ul></li><li><p><strong>写屏障（Write Barrier）</strong></p><ul><li>卡表元素如何维护的问题？</li><li>HotSpot虚拟机里是通过写屏障技术维护卡表状态的</li><li>赋值前的部分的写屏障叫作写<strong>前屏障（Pre-WriteBarrier）</strong>，在赋值后的则叫作写<strong>后屏障（Post-Write Barrier）</strong></li><li>卡表在高并发场景下还面临着“伪共享”（False Sharing）问题</li><li>JDK 7之后，HotSpot虚拟机增加了一个新的参数-XX：+UseCondCardMark，用来决定是否开启卡表更新的条件判断</li></ul><p><strong>并发的可达性分析</strong></p></li><li><p>三色标记</p><ul><li>白色：<strong>表示对象尚未被垃圾收集器访问过</strong>。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li><li>黑色：<strong>表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过</strong>。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</li><li>灰色：<strong>表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过</strong>。</li></ul></li><li><p>以下两个条件同时满足时，原本应该是黑色的对象被误标为白色：</p><ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li><li>解决方案：<strong>增量更新（Incremental Update）<strong>和</strong>原始快照（Snapshot At The Beginning，SATB）</strong></li></ul></li></ul><h3 id="2-4-经典垃圾收集器">2.4 经典垃圾收集器</h3><h4 id="2-4-1-Serial-收集器">2.4.1 Serial 收集器</h4><blockquote><p>Serial收集器是最基础、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是HotSpot虚拟机新生代收集器的唯一选择。</p></blockquote><p><strong>特点：</strong></p><ul><li>单线程工作的收集器<ul><li>只会使用一个处理器或一条收集线程去完成垃圾收集工作</li><li>进行垃圾收集时，<strong>必须暂停其他所有工作线程</strong>，直到它收集结束： <strong>Stop The World</strong></li></ul></li><li>HotSpot虚拟机运行在客户端模式下的默认新生代收集器<ul><li>简单而高效（与其他收集器的单线程相比）</li><li>内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）[插图]最小的</li><li>对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率</li></ul></li></ul><h4 id="2-4-2-ParNew-收集器">2.4.2 ParNew 收集器</h4><p><strong>ParNew收集器实质上是Serial收集器的多线程并行版本</strong></p><p><strong>除了Serial收集器外，目前只有它能与CMS收集器配合工作。</strong></p><ul><li>CMS<ul><li>HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次实现了让垃圾收集线程与用户线程（基本上）同时工作。</li><li>使用CMS来收集老年代的时候，新生代<strong>只能选择ParNew或者Serial收集器</strong>中的一个</li><li>ParNew收集器是激活CMS后（使用**-XX：+UseConcMarkSweepGC**选项）的默认新生代收集器，也可以使用-XX：+/-UseParNewGC 选项来强制指定或者禁用它。</li></ul></li></ul><blockquote><p>随着垃圾收集器技术的不断改进，更先进的<strong>G1收集器</strong>带着CMS继承者和替代者的光环登场。G1是一个<strong>面向全堆的收集器</strong>，不再需要其他新生代收集器的配合工作。所以自<strong>JDK 9开始</strong>，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。官方希望它能完全被G1所取代，甚至还取消了ParNew加SerialOld以及Serial加CMS这两组收集器组合的支持（其实原本也很少人这样使用），并直接<strong>取消了-XX：+UseParNewGC参数</strong>，这意味着ParNew和CMS从此只能互相搭配使用，再也没有其他收集器能够和它们配合了。读者也可以理解为从此以后，ParNew合并入CMS，成为它专门处理新生代的组成部分。<strong>ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器</strong></p></blockquote><ul><li>只有在多核的情况下才会优于 Serial<ul><li>ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果</li><li>由于存在线程交互的开销，该收集器在通过超线程（Hyper-Threading）技术实现的伪双核处理器环境中都不能百分之百保证超越Serial收集器</li><li>随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时系统资源的高效利用才开始显现</li></ul></li><li><strong>默认开启的收集线程数与处理器核心数量相同</strong><ul><li>可以使用**-XX：ParallelGCThreads参数来限制垃圾收集的线程数**。</li></ul></li><li>并行（Parallel）与并发（Concurrent）<ul><li>并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，<strong>通常默认此时用户线程是处于等待状态</strong>。</li><li>并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明<strong>同一时间垃圾收集器线程与用户线程都在运行</strong>。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的<strong>吞吐量将受到一定影响</strong>。</li></ul></li></ul><h4 id="2-4-3-Parallel-Scavenge-收集器">2.4.3 Parallel Scavenge 收集器</h4><p>与其他收集器不同 <strong>Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）</strong>。</p><p><strong>所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值</strong><br>$$<br>吞吐量 = \frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}<br>$$</p><ul><li><p>高吞吐量</p><ul><li>停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；</li><li>高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。</li></ul></li><li><p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量</p><ul><li>控制最大垃圾收集停顿时间的**-XX：MaxGCPauseMillis**参数</li><li>设置吞吐量大小的**-XX：GCTimeRatio**参数。</li></ul></li><li><p><strong>-XX：MaxGCPauseMillis</strong> ： 最大垃圾收集停顿时间</p><ul><li>单位毫秒，值是一个大于0的毫秒数</li><li>收集器将<strong>尽力保证</strong>内存回收花费的时间不超过用户设定值</li><li><strong>垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的</strong><ul><li>新生代调得小一些，需要收集的空间变小，收集速度自然更快</li><li>新生代空间小，会导致收集变得频繁（空间小容易被堆满）</li><li>停顿次数变多，虽然停顿的时间变短了，但是吞吐量也变小（次数*时间，总体变大了）</li></ul></li></ul></li><li><p><strong>-XX：GCTimeRatio</strong>：设置吞吐量大小</p><ul><li>值是一个大于0小于100的整数，默认值为 99</li><li><s>这是<strong>垃圾收集时间占总时间的比率</strong>，相当于1 - 吞吐量</s></li></ul><blockquote><p>from:  <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gc-ergonomics.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gc-ergonomics.html</a></p><p><code>-XX:GCTimeRatio=</code><em>nnn</em></p><p>A hint to the virtual machine that it’s desirable that not more than 1 / (1 + nnn) of the application execution time be spent in the collector.</p><p>For example <code>-XX:GCTimeRatio=19</code> sets a goal of 5% of the total time for GC and throughput goal of 95%. That is, the application should get 19 times as much time as the collector.</p><p>By default the value is 99, meaning the application should get at least 99 times as much time as the collector. That is, the collector should run for not more than 1% of the total time. This was selected as a good choice for server applications. A value that is too high will cause the size of the heap to grow to its maximum.</p></blockquote><ul><li>勘误：根据oracle官方文档，假如GCTimeRatio = nnn，那么垃圾回收的时间不应该超过应用程序执行时间的1/（1+nnn）;最大 99 意味着垃圾回收时间不能超过应用程序执行时间的 1%</li><li>譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5%（即1/(1+19)），默认值为99，即允许最大1%（即1/(1+99)）的垃圾收集时间</li></ul></li><li><p>由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作**“吞吐量优先收集器”**</p></li><li><p><strong>-XX：+UseAdaptiveSizePolicy</strong></p><ul><li>这个参数被激活之后，就<strong>不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）<strong>等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供</strong>最合适的停顿时间或者最大的吞吐量</strong></li><li>这种调节方式称为<strong>垃圾收集的自适应的调节策略（GC Ergonomics）</strong></li></ul></li></ul><h4 id="2-4-4-Serial-Old收集器">2.4.4 Serial Old收集器</h4><p><strong>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法</strong></p><ul><li>收集器的主要意义也是供<strong>客户端模式下的HotSpot虚拟机使用</strong></li><li>用途：<ul><li>一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用</li><li>另外一种就是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用</li></ul></li></ul><h4 id="2-4-5-Parallel-Old收集器">2.4.5 Parallel Old收集器</h4><p><strong>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</strong></p><ul><li>在注重<strong>吞吐量</strong>或者<strong>处理器资源较为稀缺</strong>的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合</li></ul><h4 id="2-4-6-CMS收集器">2.4.6 CMS收集器</h4><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现的</strong></p><ul><li>运作过程相对要更复杂一些，整个过程分为<strong>四个步骤</strong><ul><li>1.初始标记（CMS initial mark）<ul><li>标记一下GC Roots能直接关联到的对象，速度很快</li></ul></li><li>2.并发标记（CMS concurrent mark）<ul><li>从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行</li></ul></li><li>3.重新标记（CMS remark）<ul><li>为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li><li>会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</li></ul></li><li>4.并发清除（CMS concurrent sweep）<ul><li>清理删除掉标记阶段判断的已经死亡的对象</li><li>由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul></li></ul></li><li>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”</li></ul><blockquote><p>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p></blockquote><ul><li><p>优点： 并发收集、低停顿</p></li><li><p>缺点：</p><ul><li><p>CMS收集器对处理器资源非常敏感</p><ul><li>并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，<strong>降低总吞吐量</strong></li><li><strong>CMS默认启动的回收线程数是（处理器核心数量+3）/4</strong></li><li>四核以上时只占用不超过25%的处理器运算资源，但是低于四核时CMS对用户程序的影响就可能变得很大</li></ul></li><li><p>由于CMS收集器无法处理**“浮动垃圾”（Floating Garbage）**，有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。</p><ul><li><strong>“浮动垃圾”（Floating Garbage）</strong>： 并发阶段产生的垃圾，在当次垃圾收集中无法被回收，只能下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。</li><li>CMS无法等到老年代完全被填满时收集，必须预留一部分空间供并发收集时的程序运作使用</li><li>在JDK 5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活， 可以适当调高参数 <strong>-XX：CMSInitiatingOccu-pancyFraction</strong>的值来提高CMS的触发百分比</li><li>JDK 6时，CMS收集器的启动阈值就已经默认提升至92%</li></ul><blockquote><p>这又会更容易面临另一种风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent ModeFailure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。所以参数 <strong>-XX：CMSInitiatingOccupancyFraction</strong> 设置得太高将会很容易导致大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置。</p></blockquote></li><li><p>CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生</p><ul><li>CMS收集器提供了一个**-XX：+UseCMS-CompactAtFullCollection**开关参数（默认是开启的，此参数从JDK 9开始废弃）：用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的。这样空间碎片问题是解决了，但停顿时间又会变长</li><li>另外一个参数 <strong>-XX：CMSFullGCsBefore-Compaction</strong>（此参数从JDK 9开始废弃），这个参数的作用是要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入FullGC前会先进行碎片整理（默认值为0，表示每次进入Full GC时都进行碎片整理）。</li></ul></li></ul></li></ul><h4 id="2-4-7-Garbage-First收集器">2.4.7 Garbage First收集器</h4><p><strong>Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。</strong></p><ul><li>历史<ul><li>从JDK 6 Update 14开始就有Early Access版本的G1收集器供开发人员实验和试用，但由此开始G1收集器的“实验状态”（Experimental）持续了数年时间</li><li>直至JDK 7 Update 4，Oracle才认为它达到足够成熟的商用程度，移除了“Experimental”的标识</li><li>JDK 8 Update 40 G1提供并发的类卸载的支持，补全了其计划功能的最后一块拼图。这个版本以后的G1收集器才被Oracle官方称为“<strong>全功能的垃圾收集器”（Fully-Featured Garbage Collector）</strong></li><li>JDK 9发布之日，<strong>G1宣告取代Parallel Scavenge加ParallelOld组合</strong>，成为服务端模式下的<strong>默认垃圾收集器</strong>，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器</li></ul></li></ul><blockquote><p>在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。而G1跳出了这个樊笼，它可以<strong>面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收</strong>，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的MixedGC模式。</p></blockquote><ul><li>G1 是<strong>基于Region的堆内存布局</strong></li></ul><blockquote><p>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p></blockquote><h3 id="2-5-低延迟垃圾收集器">2.5 低延迟垃圾收集器</h3><p>垃圾收集器的<strong>三项最重要的指标</strong>是：<strong>内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency）</strong></p><ul><li>三个方面同时具有卓越表现的“完美”收集器是极其困难甚至是不可能的</li><li>一款优秀的收集器通常最多可以同时<strong>达成其中的两项</strong></li></ul><h3 id="2-6-选择合适的垃圾收集器">2.6 选择合适的垃圾收集器</h3><h3 id="2-7-内存分配与回收策略">2.7 内存分配与回收策略</h3><h4 id="2-7-1-对象优先在Eden分配">2.7.1 对象优先在Eden分配</h4><p>大多数情况下，<strong>对象在新生代<code>Eden</code>区中分配</strong>。当 <code>Eden</code>区没有足够空间进行分配时，虚拟机将发起一次 <code>Minor GC</code></p><ul><li><code>-XX：+PrintGCDetails</code>  发生垃圾收集行为时<strong>打印内存回收日志</strong>，并且在进程<strong>退出的时候输出当前的内存各区域分配情况</strong></li></ul><h4 id="2-7-2-大对象直接进入老年代">2.7.2 大对象直接进入老年代</h4><p>大对象就是指需要<strong>大量连续内存空间的Java对象</strong></p><ul><li>最典型的大对象便是那种很长的字符串</li><li>或者元素数量很庞大的数组</li></ul><p>写程序时,应注意避免大对象：</p><ul><li>分配空间时，它容易导致内存明明还有不少空间时就提<strong>前触发垃圾收集</strong>（获取连续内存空间）</li><li>复制对象时，大对象就意味着高额的<strong>内存复制开销</strong></li><li><code>-XX：PretenureSizeThreshold</code> 参数，指定<strong>大于该设置值的对象直接在老年代分配</strong>，这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。<ul><li>参数只对Serial和ParNew两款新生代收集器有效</li></ul></li></ul><h4 id="2-7-3-长期存活的对象将进入老年代">2.7.3 长期存活的对象将进入老年代</h4><p><strong>虚拟机给每个对象定义了一个对象年龄（<code>Age</code>）计数器，存储在对象头中</strong></p><ul><li>对象通常在Eden区里诞生</li><li>经过第一次 <code>Minor GC</code> 后仍然存活，并且能被 <code>Survivor</code> 容纳的话，该对象会被移动到 <code>Survivor</code> 空间中，并且将其对象年龄设为1岁</li><li>每熬过一次 <code>Minor GC</code>，年龄就增加1岁</li><li>当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中</li><li><code>-XX：MaxTenuringThreshold</code> 可以设置对象晋升老年代的年龄<strong>阈值</strong></li></ul><h4 id="2-7-4-动态对象年龄判定">2.7.4  动态对象年龄判定</h4><blockquote><p>HotSpot虚拟机并不是永远要求对象的年龄必须达到-XX：MaxTenuringThreshold才能晋升老年代，<strong>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半</strong>，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX：MaxTenuringThreshold中要求的年龄。</p></blockquote><h4 id="2-7-5-空间分配担保">2.7.5 空间分配担保</h4><blockquote><p>在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-XX：HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX：HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次FullGC</p></blockquote><h2 id="3-虚拟机性能监控、故障处理工具">3. 虚拟机性能监控、故障处理工具</h2><h3 id="3-1-基础故障处理工具">3.1 基础故障处理工具</h3><h4 id="3-1-1-jps：虚拟机进程状况工具">3.1.1 jps：虚拟机进程状况工具</h4><p><code>JVM ProcessStatus Tool</code></p><p>可以<strong>列出正在运行的虚拟机进程</strong>，并<strong>显示虚拟机执行主类</strong>（Main Class，main()函数所在的类）名称以及这些进<strong>程的本地虚拟机唯一ID</strong>（LVMID，LocalVirtual Machine Identifier）</p><p>对于本地虚拟机进程来说，LVMID与操作系统的进程ID（PID，Process Identifier）是一致的</p><p>jps还可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，参数hostid为RMI注册表中注册的主机名。</p><p><strong>参数选项</strong></p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-q</td><td>只输出LVMID，省略主类的名称</td></tr><tr><td>-m</td><td>输出虚拟机进程启动时传递给主类 main() 函数的参数</td></tr><tr><td>-l</td><td>输出主类的全名，如果进程执行的是 JAR 包， 则输出 JAR 路径</td></tr><tr><td>-v</td><td>输出虚拟机进程启动时的 JVM 参数</td></tr></tbody></table><h4 id="3-1-2-jstat：虚拟机统计信息监视工具">3.1.2 jstat：虚拟机统计信息监视工具</h4><p><code>jstat（JVM Statistics Monitoring Tool）</code>是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的<strong>类加载、内存、垃圾收集、即时编译等运行时数据</strong>，在没有GUI图形界面、只提供了纯文本控制台环境的服务器上，它将是<strong>运行期定位虚拟机性能问题的常用工具</strong>。</p><p><strong>格式：</strong></p><blockquote><p>jstat [ option vmid [interval[s|ms] [count]] ]</p></blockquote><ul><li>对于命令格式中的<strong>VMID与LVMID</strong>：如果果是本地虚拟机进程，VMID与LVMID是一致的；如果是<strong>远程虚拟机进程</strong>，那VMID的格式应当是：</li></ul><blockquote><p>[ protocol:][//]lvmid[@hostname[:port]/servername]</p></blockquote><ul><li>参数interval和count代表查询间隔和次数，如果省略这2个参数，说明只查询一次</li><li>假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，命令如下：</li></ul><blockquote><p>jstat -gc 2764 250 20</p></blockquote><ul><li>选项option代表用户希望查询的虚拟机信息，主要分为三类：类加载、垃圾收集、运行期编译状况：</li></ul><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视类加载、卸载数量、总空间以及类装载所耗费的时间</td></tr><tr><td>-gc</td><td>监视 java 状况，包括 Eden 区， 2个 Survivor 区、老年代、永久代等的容量，<br>已用空间，垃圾收集时间合计等信息</td></tr><tr><td>-gccapactiy</td><td>监视内容与 -gc 基本相同，但输出的主要关注 java 堆各个区域使用到的最大。<br>最小空间</td></tr><tr><td>-gcutil</td><td>监视内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td>-gccause</td><td>与 -gcutil 功能一样，但是会额外输出导致上一次垃圾收集产生的原因</td></tr><tr><td>-gcnew</td><td>监视新生代垃圾收集情况</td></tr><tr><td>-gcnewcapacity</td><td>监视内容与 -gcnew 基本相同，但输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcold</td><td>监视老年代垃圾收集情况</td></tr><tr><td>-gcoldcapacity</td><td>监视内容与-gcold 基本相同，但输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcpermcapacity</td><td>输出拥挤代使用到的最大、最小空间</td></tr><tr><td>-compiler</td><td>输出即时编译器编译过的方法，耗时等信息</td></tr><tr><td>-printcompilation</td><td>输出已经被即时编译的方法</td></tr></tbody></table><p><strong>命令示例</strong></p><ul><li><p>-gcutil</p><blockquote><p>$ jstat -gcutil 107581<br>S0        S1     E           O        M     CCS     YGC     YGCT    FGC    FGCT     GCT<br>69.46   0.00  61.76  66.77  95.57  93.59   9840   71.693     8    2.304   73.997</p></blockquote><ul><li><code>S0</code> : Survivor0 ，使用 69.46%</li><li><code>S1</code> : Survivor1 ，使用 0%</li><li><code>E</code>   : Eden ，使用 61.76%</li><li><code>O</code>   : olde 老年代，使用 66.77%</li><li><code>P</code>   : 这里没有（jdk1.8），表示 Permanent 永久代</li><li><code>M</code>  : Metaspace ,原空间，使用 95.57%</li><li><code>CCS</code>： Compressed class space，压缩类空间利用率为百分比</li><li><code>YGC</code>: Young GC，表示发生 Minor GC 的次数，9840 次</li><li><code>YGCT</code>: 表示发生 Minor GC 的总耗时，总耗时 71.693 秒</li><li><code>FGC</code>: Full GC，表示发生 Full  GC 的次数，8 次</li><li><code>FGCT</code>: 表示发生 Full GC 的总耗时， 总耗时 2.304 秒</li><li><code>GCT</code>: 垃圾回收总时间，总耗时 73.997 秒</li></ul></li></ul><h4 id="3-1-3-jinfo：Java配置信息工具">3.1.3  jinfo：Java配置信息工具</h4><p>jinfo（Configuration Info for Java）的作用是<strong>实时查看和调整虚拟机各项参数</strong></p><p><strong>jinfo命令格式：</strong></p><blockquote><p>jinfo [option] &lt;pid&gt;</p></blockquote><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-flag &lt;name&gt;</td><td>打印 name 的 jvm 参数的值</td></tr><tr><td>-flag [+|-]&lt;name&gt;</td><td>添加或者删除(使…有效|无效) name 属性</td></tr><tr><td>-flag &lt;name&gt;=&lt;value&gt;</td><td>设置 name 属性的值为 value</td></tr><tr><td>-flags</td><td>答应 vm flags</td></tr><tr><td>-sysprops</td><td>打印 java system properties</td></tr><tr><td>&lt;no option&gt;</td><td>答应所有配置</td></tr></tbody></table><p><strong>使用示例</strong></p><blockquote><p>$ jinfo -flag MaxHeapSize 107581<br>-XX:MaxHeapSize=536870912</p><p>$ jinfo -flags 107581<br>Attaching to process ID 107581, please wait…<br>Debugger attached successfully.<br>Server compiler detected.<br>JVM version is 25.92-b14<br>Non-default VM flags: -XX:CICompilerCount=4 -XX:InitialHeapSize=268435456 -XX:MaxHeapSize=536870912 -XX:MaxNewSize=178782208 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=89128960 -XX:OldSize=179306496 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC<br>Command line:  -Xms256m -Xmx512m -XX:+UseParallelGC -javaagent:/data/agent/skywalking-agent.jar -Dskywalking.agent.service_name=external-gateway-server -javaagent:/opt/bonree/apm/agent/java/6.2.11/bonree.jar -Dbonree.smartagent=true</p><p>$ jinfo -sysprops 107581<br>Attaching to process ID 107581, please wait…<br>Debugger attached successfully.<br>Server compiler detected.<br>JVM version is 25.92-b14<br><a href="http://java.runtime.name">java.runtime.name</a> = Java™ SE Runtime Environment<br>logPath = /data/logs<br>sun.rmi.transport.tcp.responseTimeout = 200000<br>…</p></blockquote><h4 id="3-1-4-jmap：Java内存映像工具">3.1.4  jmap：Java内存映像工具</h4><p><strong>jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）</strong></p><p><strong>用途：</strong></p><ul><li>获取堆转储快照</li><li>查询finalize执行队列、Java堆和方法区的详细信息</li><li>空间使用率</li><li>用的是哪种收集器</li></ul><p><strong>命令格式</strong></p><blockquote><p>jmap [ option ] vid</p></blockquote><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-dump</td><td>生成 java 堆转存快照，格式为：<br> -dump: [live,] format=b, file=&lt;filename&gt; &lt;\pid&gt;,<br>其中 live 子参数说明是否只 dump 出存活的对象</td></tr><tr><td>-finalizerinfo</td><td>显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象。<br>只在 Linux/Solaris 平台下有效</td></tr><tr><td>-heap</td><td>显示 java 堆详细信息，如使用哪种回收器、参数配置、分代状况等。<br>只在 Linux/Solaris 平台下有效</td></tr><tr><td>-histo</td><td>显示堆中对象统计信息，包括类、实例数量、合计容量</td></tr><tr><td>-permstat</td><td>以 ClassLoader 为统计口径显示永久代内存状态。<br>只在 Linux/Solaris 平台下有效<br>jdk1.8 已经删除这个操作（因为没有永久代）</td></tr><tr><td>-F</td><td>当虚拟机进程对 -dump 选项没有响应时，可使用这个选项强制生<br>成 dump 快照。 在 Linux/Solaris 平台下有效</td></tr><tr><td>-clstats</td><td>打印类加载器统计信息</td></tr></tbody></table><h4 id="3-1-5-jhat：虚拟机堆转储快照分析工具">3.1.5 jhat：虚拟机堆转储快照分析工具</h4><p><strong>jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。</strong></p><p><strong>jhat的分析功能相对来说比较简陋,一般不使用</strong></p><h4 id="3-1-6-jstack：Java堆栈跟踪工具">3.1.6 jstack：Java堆栈跟踪工具</h4><p><strong>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照</strong>（一般称为threaddump或者javacore文件）</p><p><strong>命令格式</strong></p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-F</td><td>单正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td>-l</td><td>除堆栈外，显示关于锁的附加信息</td></tr><tr><td>-m</td><td>如果调用到本地方法的话。可以显示 C/C++ 堆栈</td></tr></tbody></table><h4 id="3-1-7-总结">3.1.7 总结</h4><p>。。。</p><h3 id="3-2-可视化故障处理工具">3.2 可视化故障处理工具</h3><table><thead><tr><th>工具</th><th>说明</th></tr></thead><tbody><tr><td>JConsole</td><td>最古老的，在JDK 5时期就已经存在的虚拟机监控工具<br>JDK中的正式成员，跟随jdk一起发布</td></tr><tr><td>JHSDB</td><td>JHSDB虽然名义上是JDK 9中才正式提供<br>但之前已经以sa-jdi.jar包里面的HSDB（可视化工具）<br>和CLHSDB（命令行工具）的形式存在了很长一段时间<br/>JDK中的正式成员，跟随jdk一起发布</td></tr><tr><td>VisualVM</td><td>JDK 6 Update 7中首次发布<br>现在成为一个独立发展的开源项目<br>不是JDK中的正式成员，需要下载</td></tr><tr><td>JMC<br>(Java Mission Control)</td><td>BEA公司的图形化诊断工具<br>JDK 7 Update 40时开始随JDK一起发布<br>从JDK 11开始又被移除出JDK<br>在生产环境是需要付费的</td></tr></tbody></table><h4 id="3-2-1-JHSDB：基于服务性代理的调试工具">3.2.1 JHSDB：基于服务性代理的调试工具</h4><p><strong>JCMD、JHSDB和基础工具对比</strong></p><table><thead><tr><th>基础工具</th><th>JCMD</th><th>JHSDB</th></tr></thead><tbody><tr><td>jps -lm</td><td>jcmd</td><td>N/A</td></tr><tr><td>jamp -dump &lt;pid&gt;</td><td>jcmd &lt;pid&gt; GC heap_dump</td><td>jhsdb jmap --binaryheap</td></tr><tr><td>jmap -histo &lt;pid&gt;</td><td>jcmd &lt;pid&gt; GC class_hsitogram</td><td>jhsdb jmap --histo</td></tr><tr><td>jstack &lt;pid&gt;</td><td>jcmd &lt;pid&gt; Thread.print</td><td>jhsdb jstack --locks</td></tr><tr><td>jinfo -sysprops &lt;pid&gt;</td><td>jcmd &lt;pid&gt; VM.system_properties</td><td>jhsdb info --sysprops</td></tr><tr><td>jinfo -flags &lt;pid&gt;</td><td>jcmd &lt;pid&gt; VM.flags</td><td>jhsdb jinfo --flags</td></tr></tbody></table><p><em>命令行方式这里不提，以下主要介绍可视化</em></p><p><strong>JHSDB是一款基于服务性代理（Serviceability Agent，SA）实现的进程外调试工具。</strong></p><ul><li>由于JHSDB本身对压缩指针的支持存在很多缺陷，建议用64位系统的读者在实验时禁用压缩指针</li></ul><pre><code>Heap Parameters:Gen 0:   eden [0x0000000019c00000,0x0000000019c5a9f8,0x0000000019eb0000) space capacity = 2818048, 13.17195448764535 used  from [0x0000000019f00000,0x0000000019f50000,0x0000000019f50000) space capacity = 327680, 100.0 used  to   [0x0000000019eb0000,0x0000000019eb0000,0x0000000019f00000) space capacity = 327680, 0.0 usedInvocations: 1Gen 1:   old  [0x0000000019f50000,0x000000001a0724e8,0x000000001a600000) space capacity = 7012352, 16.95716358790888 usedInvocations: 0</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1&gt;jvm 内存管理&lt;/h1&gt;
&lt;h2 id=&quot;1-Java内存区域与内存溢出异常&quot;&gt;1. Java内存区域与内存溢出异常&lt;/h2&gt;
&lt;h3 id=&quot;1-1-运行时数据区域&quot;&gt;1.1 运行时数据区域&lt;/h3&gt;
&lt;p&gt;对于运行时数据区域被划分为5个区域，&lt;em&gt;&lt;strong&gt;方法区（Method Area）&lt;/strong&gt;&lt;/em&gt; ,&lt;strong&gt;虚拟机栈（VM Stack）&lt;/strong&gt;, &lt;strong&gt;本地方法栈（Native Method Stack)&lt;/strong&gt;, &lt;em&gt;&lt;strong&gt;堆（Heap）&lt;/strong&gt;&lt;/em&gt;，&lt;strong&gt;程序计数器（Program Counter Register)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法区 和 堆 由所有线程共享，其他是线程隔离的。&lt;/p&gt;
&lt;h4 id=&quot;1-1-1-程序计数器&quot;&gt;1.1.1 程序计数器&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;当前线程所执行的字节码的行号指示器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令&lt;/li&gt;
&lt;li&gt;Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，所以需要每个线程独立存储自己的指示器&lt;/li&gt;
&lt;li&gt;线程执行Java方法时，这个计数器记录的是正在执行的虚拟机字节码指令的地址；&lt;/li&gt;
&lt;li&gt;线程执行的是本地（Native）方法，这个计数器值则应为空（Undefined）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="java" scheme="https://xuzhuohao.github.io/categories/java/"/>
    
    
    <category term="jvm" scheme="https://xuzhuohao.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://xuzhuohao.github.io/tags/java/"/>
    
    <category term="base" scheme="https://xuzhuohao.github.io/tags/base/"/>
    
  </entry>
  
</feed>
